{
  "master": {
    "tasks": [
      {
        "id": 16,
        "title": "Setup Project Structure with Clean Architecture",
        "description": "Initialize the Go project with proper module structure following Clean Architecture and DDD principles as specified in the PRD.",
        "details": "1. Initialize Go module with `go mod init payment-processor`\n2. Create directory structure following the PRD specifications:\n   - internal/domain/ (payment, shared)\n   - internal/application/ (command, query, port, service)\n   - internal/infrastructure/ (persistence, http, worker)\n3. Setup go.mod with Go 1.24.4 requirement\n4. Configure basic linting tools: gofmt, go vet, golint, staticcheck\n5. Create initial README.md with project overview\n6. Setup .gitignore file for Go projects\n7. Create Makefile with common commands (build, test, lint)\n8. Initialize basic configuration management structure using environment variables\n9. Setup conventional commits git hooks",
        "testStrategy": "Verify directory structure matches PRD specifications. Ensure go.mod is properly configured with correct Go version. Validate that all development tools can be executed via Makefile commands.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement Domain Layer Core Entities",
        "description": "Create the core domain entities and value objects for the payment processing system following DDD principles.",
        "details": "1. Create Payment aggregate root in domain/payment/payment.go with rich behavior:\n   - Constructor with validation\n   - Status transition methods (markAsProcessed, markAsFailed)\n   - Business rules enforcement\n2. Implement value objects in domain/shared/:\n   - iban.go: IBAN value object with format validation\n   - amount.go: Amount value object with decimal handling\n   - idempotency_key.go: IdempotencyKey with uniqueness validation\n3. Create PaymentStatus enum in domain/payment/payment_status.go\n4. Define domain errors in domain/shared/errors.go\n5. Define repository interfaces in domain/payment/repository.go\n6. Implement domain services in domain/payment/service.go\n\nUse Go 1.18+ generics where appropriate for type safety. Ensure all domain objects are immutable where possible.",
        "testStrategy": "Implement comprehensive table-driven tests for all domain entities and value objects. Test validation rules, business logic, and state transitions. Use property-based testing for IBAN validation. Achieve >90% test coverage for domain layer.",
        "priority": "high",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Design and Implement SQLite Database Schema",
        "description": "Create the SQLite database schema for payment records with proper indexes and constraints.",
        "details": "1. Create SQLite database schema with the following tables:\n   - payments: id (primary key), debtor_iban, debtor_name, creditor_iban, creditor_name, amount, currency, idempotency_key (unique), status, created_at, updated_at\n2. Add appropriate indexes:\n   - Unique index on idempotency_key\n   - Index on status for efficient filtering\n   - Index on created_at for chronological queries\n3. Implement database migration using a lightweight migration tool like golang-migrate\n4. Create SQL scripts for:\n   - Schema creation\n   - Indexes\n   - Test data population\n5. Implement connection pooling with proper configuration\n6. Add database health check query\n\nUse parameterized queries throughout to prevent SQL injection. Configure appropriate connection pool settings with timeouts.",
        "testStrategy": "Create integration tests that verify schema creation, constraint enforcement, and index usage. Test unique constraint on idempotency_key. Verify connection pooling works correctly under load. Test migration scripts for both up and down migrations.",
        "priority": "high",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement Application Layer Command Handlers",
        "description": "Create application layer command handlers for processing payment creation and status updates.",
        "details": "1. Implement CreatePaymentCommand and handler in application/command/create_payment.go:\n   - Define command struct with all payment fields\n   - Implement handler with proper validation\n   - Use context for timeout and cancellation\n   - Return appropriate domain errors\n2. Implement UpdatePaymentStatusCommand and handler in application/command/update_status.go:\n   - Define command struct with payment ID and new status\n   - Implement handler with status transition validation\n   - Use context for timeout and cancellation\n3. Define application interfaces in application/port/:\n   - payment_persister.go: Interface for dual persistence\n   - xml_generator.go: Interface for XML generation\n4. Implement PaymentService in application/service/payment_service.go to orchestrate operations\n\nUse dependency injection for all external dependencies. Implement proper error handling with domain-specific errors.",
        "testStrategy": "Create unit tests for command handlers using gomock to mock dependencies. Test validation logic, error handling, and successful execution paths. Verify context cancellation is properly handled. Test edge cases like duplicate idempotency keys.",
        "priority": "high",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Implement SQLite Repository",
        "description": "Create the SQLite repository implementation for the payment domain repository interface.",
        "details": "1. Implement PaymentRepository in infrastructure/persistence/sqlite/payment_repository.go:\n   - Implement Create method with proper transaction handling\n   - Implement FindByID method\n   - Implement FindByIdempotencyKey method\n   - Implement UpdateStatus method\n   - Implement transaction management with context support\n2. Use database/sql package with proper connection pooling\n3. Implement parameterized queries for all database operations\n4. Add proper error handling and mapping to domain errors\n5. Implement timeout handling using context\n6. Add metrics for query execution time\n\nUse prepared statements for better performance. Implement proper resource cleanup with defer statements. Use context for cancellation and timeouts.",
        "testStrategy": "Create integration tests that verify repository operations against a real SQLite database. Test transaction rollback on error. Test concurrent operations. Verify proper error mapping. Test timeout handling with context cancellation.",
        "priority": "high",
        "dependencies": [
          17,
          18
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement XML File Generator",
        "description": "Create the XML file generator for persisting payment data in XML format.",
        "details": "1. Implement XMLGenerator in infrastructure/persistence/xml/payment_xml_generator.go:\n   - Implement GenerateXML method to create XML from payment data\n   - Implement SaveXML method to write XML to file system\n   - Use encoding/xml package for XML generation\n   - Implement proper file naming convention\n   - Add file system error handling\n2. Create XML structure matching the requirements\n3. Implement file system operations with proper error handling\n4. Add atomic file write operations to prevent partial writes\n5. Implement directory structure for organizing XML files\n6. Add file cleanup mechanism for old XML files\n\nUse os.WriteFile with temporary file and rename for atomic writes. Implement proper error handling for file system operations.",
        "testStrategy": "Create unit tests for XML generation logic. Create integration tests for file system operations. Verify XML structure matches requirements. Test error handling for file system failures. Test atomic write operations.",
        "priority": "high",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Implement Dual Persistence Transaction Manager",
        "description": "Create a transaction manager that ensures atomic operations across both SQLite and XML persistence.",
        "details": "1. Implement TransactionManager in infrastructure/persistence/transaction_manager.go:\n   - Define interface for transactional operations\n   - Implement method to execute operations in transaction\n   - Ensure rollback on failure for both SQLite and XML\n   - Implement compensation logic for XML file deletion on rollback\n2. Integrate with SQLite transaction mechanism\n3. Implement file system rollback mechanism\n4. Add proper error handling and logging\n5. Implement retry mechanism for transient failures\n\nUse a two-phase approach: prepare both operations, then commit both. On failure, roll back both operations. Use proper error handling and logging for rollback operations.",
        "testStrategy": "Create integration tests that verify atomic operations across both persistence mechanisms. Test rollback scenarios. Test partial failures. Verify no orphaned records between SQLite and XML. Test retry mechanism for transient failures.",
        "priority": "high",
        "dependencies": [
          20,
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement JSON Schema Validation",
        "description": "Create JSON schema validation for payment request validation.",
        "details": "1. Define JSON schema for payment request in infrastructure/http/schema/payment_schema.json:\n   - debtor_iban (string, IBAN format)\n   - debtor_name (string, 3-30 chars)\n   - creditor_iban (string, IBAN format)\n   - creditor_name (string, 3-30 chars)\n   - amount (number)\n   - idempotency_unique_key (string, 10 chars)\n2. Implement validator in infrastructure/http/validator/payment_validator.go\n3. Use a lightweight JSON schema validation library like github.com/xeipuuv/gojsonschema (v1.2.0)\n4. Implement custom validation for IBAN format\n5. Add detailed error messages for validation failures\n6. Implement validation middleware for HTTP handlers\n\nReturn detailed validation errors with field names and reasons. Implement custom validators for domain-specific rules.",
        "testStrategy": "Create table-driven tests for validation logic. Test valid and invalid requests. Test edge cases like boundary values. Verify error messages are clear and helpful. Test custom validators for IBAN format.",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Implement HTTP Authentication Middleware",
        "description": "Create HTTP basic authentication middleware for securing API endpoints.",
        "details": "1. Implement authentication middleware in infrastructure/http/middleware/auth.go:\n   - Parse Authorization header\n   - Validate credentials against configuration\n   - Implement proper error handling for missing or invalid credentials\n   - Add logging for authentication failures\n2. Use environment variables for credential configuration\n3. Implement secure credential comparison to prevent timing attacks\n4. Add rate limiting for failed authentication attempts\n5. Implement proper HTTP status codes (401 for authentication failures)\n\nUse the standard library's subtle.ConstantTimeCompare for secure credential comparison. Implement proper logging for security events.",
        "testStrategy": "Create unit tests for authentication middleware. Test valid credentials, invalid credentials, missing credentials. Test rate limiting for failed attempts. Verify proper HTTP status codes and headers in responses.",
        "priority": "high",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Implement Payment API Endpoint",
        "description": "Create the REST API endpoint for payment submission.",
        "details": "1. Implement PaymentHandler in infrastructure/http/handler/payment_handler.go:\n   - Implement POST /v1/payments endpoint\n   - Parse and validate request body\n   - Convert request to command\n   - Call application service\n   - Format response with payment ID\n   - Implement proper error handling\n2. Use standard library's net/http package\n3. Implement middleware chain with authentication and logging\n4. Add request ID generation for correlation\n5. Implement proper HTTP status codes\n6. Add response headers (Content-Type, etc.)\n\nUse context for request cancellation and timeouts. Implement proper error handling with appropriate HTTP status codes.",
        "testStrategy": "Create unit tests for handler logic using httptest package. Test successful requests, validation failures, authentication failures. Verify proper HTTP status codes and response bodies. Test request cancellation and timeouts.",
        "priority": "high",
        "dependencies": [
          19,
          23,
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Implement Health Check Endpoint",
        "description": "Create a health check endpoint for monitoring system health.",
        "details": "1. Implement HealthHandler in infrastructure/http/handler/health_handler.go:\n   - Implement GET /health endpoint\n   - Check database connectivity\n   - Check file system access\n   - Return health status in JSON format\n   - Include component status details\n2. Implement proper error handling\n3. Add response caching to prevent frequent checks\n4. Include version information in response\n5. Add uptime information\n\nReturn detailed component status information. Use proper HTTP status codes (200 for healthy, 503 for unhealthy).",
        "testStrategy": "Create unit tests for health check logic. Test scenarios with all components healthy and with various component failures. Verify proper HTTP status codes and response format.",
        "priority": "medium",
        "dependencies": [
          20,
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement Metrics Endpoint",
        "description": "Create a metrics endpoint for exposing application metrics.",
        "details": "1. Implement MetricsHandler in infrastructure/http/handler/metrics_handler.go:\n   - Implement GET /metrics endpoint\n   - Expose request count, response times, error rates\n   - Expose business metrics (payment creation rate, success/failure ratios)\n   - Format metrics in Prometheus-compatible format\n2. Implement metrics collection throughout the application\n3. Use a lightweight metrics library like github.com/prometheus/client_golang (v1.16.0)\n4. Add labels for detailed metrics analysis\n5. Implement histogram for response time distribution\n\nUse middleware to collect request metrics. Implement business metrics in application services.",
        "testStrategy": "Create unit tests for metrics collection logic. Verify metrics are properly incremented. Test metric labels. Verify Prometheus-compatible format.",
        "priority": "low",
        "dependencies": [
          25
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Implement Structured Logging",
        "description": "Implement structured logging throughout the application.",
        "details": "1. Implement logging infrastructure in infrastructure/logging/logger.go:\n   - Use Go's standard library slog package (introduced in Go 1.21)\n   - Configure JSON output format\n   - Define log levels (DEBUG, INFO, WARN, ERROR)\n   - Implement context-aware logging with request ID\n   - Add common fields (timestamp, service name, etc.)\n2. Implement logging middleware for HTTP requests\n3. Add logging throughout application components\n4. Implement log level configuration via environment variables\n5. Add performance logging for slow operations\n\nUse structured logging with consistent field names. Include contextual information in all log entries.",
        "testStrategy": "Create unit tests for logging logic. Verify log format and content. Test different log levels. Verify context values are properly included in log entries.",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Implement Background Worker for CSV Processing",
        "description": "Create a background worker for processing bank response CSV files.",
        "details": "1. Implement StatusUpdater in infrastructure/worker/status_updater.go:\n   - Implement file monitoring logic using fsnotify (github.com/fsnotify/fsnotify v1.6.0)\n   - Parse CSV file using encoding/csv package\n   - Process CSV rows in batches\n   - Update payment status in database\n   - Implement proper error handling and retry logic\n2. Use goroutine for background processing\n3. Implement graceful shutdown\n4. Add file locking to prevent concurrent processing\n5. Implement batch processing with transactions\n6. Add metrics for processed records\n\nUse a channel-based approach for processing CSV rows. Implement proper error handling and logging for background processing.",
        "testStrategy": "Create integration tests for CSV processing logic. Test file monitoring, parsing, and database updates. Test error handling and retry logic. Verify atomic batch processing. Test graceful shutdown.",
        "priority": "high",
        "dependencies": [
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Implement Configuration Management",
        "description": "Create configuration management for application settings.",
        "details": "1. Implement configuration in infrastructure/config/config.go:\n   - Define configuration struct with all settings\n   - Load configuration from environment variables\n   - Implement validation for required settings\n   - Provide sensible defaults\n   - Add support for configuration file (optional)\n2. Include settings for:\n   - HTTP server (port, timeouts)\n   - Database (connection string, pool size)\n   - File system (paths for XML and CSV)\n   - Authentication (credentials)\n   - Logging (level, format)\n3. Implement validation for all settings\n4. Add logging of configuration at startup (excluding sensitive values)\n\nUse environment variables as the primary configuration source. Implement proper validation for all settings.",
        "testStrategy": "Create unit tests for configuration loading and validation. Test with valid and invalid configurations. Test default values. Verify sensitive values are not logged.",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implement Error Handling Framework",
        "description": "Create a comprehensive error handling framework for the application.",
        "details": "1. Implement error types in domain/shared/errors.go:\n   - Define error categories (ValidationError, BusinessError, SystemError)\n   - Implement error wrapping for context preservation\n   - Add error codes for client-friendly messages\n2. Implement error handling middleware in infrastructure/http/middleware/error_handler.go:\n   - Convert domain errors to HTTP responses\n   - Map error types to HTTP status codes\n   - Format error responses in consistent JSON format\n   - Hide internal details in production\n3. Implement logging for all errors\n4. Add stack traces for system errors\n\nUse Go 1.13+ error wrapping with errors.Is and errors.As for error type checking. Implement proper error context preservation.",
        "testStrategy": "Create unit tests for error handling logic. Test error wrapping and unwrapping. Test error type mapping to HTTP status codes. Verify error response format. Test different error categories.",
        "priority": "medium",
        "dependencies": [
          16,
          28
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Implement Graceful Shutdown",
        "description": "Implement graceful shutdown for the application.",
        "details": "1. Implement shutdown logic in cmd/server/main.go:\n   - Capture SIGTERM and SIGINT signals\n   - Initiate graceful shutdown of HTTP server\n   - Close database connections\n   - Stop background workers\n   - Wait for in-flight requests to complete\n   - Log shutdown progress\n2. Implement timeout for shutdown process\n3. Add health check status update during shutdown\n4. Implement connection draining for HTTP server\n\nUse context cancellation for coordinating shutdown across components. Implement proper resource cleanup.",
        "testStrategy": "Create integration tests for graceful shutdown. Test shutdown with in-flight requests. Verify resources are properly cleaned up. Test shutdown timeout.",
        "priority": "medium",
        "dependencies": [
          25,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Implement Idempotency Key Validation",
        "description": "Implement idempotency key validation to prevent duplicate payments.",
        "details": "1. Enhance PaymentRepository with FindByIdempotencyKey method\n2. Implement idempotency check in CreatePaymentCommand handler:\n   - Check if payment with same idempotency key exists\n   - Return existing payment ID if found\n   - Proceed with creation if not found\n3. Add proper error handling for duplicate keys\n4. Implement database index on idempotency_key column\n5. Add metrics for duplicate requests\n\nUse database unique constraint as the ultimate guarantee against duplicates. Implement proper error handling for constraint violations.",
        "testStrategy": "Create integration tests for idempotency logic. Test duplicate requests with same idempotency key. Verify same response is returned for duplicate requests. Test concurrent requests with same idempotency key.",
        "priority": "high",
        "dependencies": [
          20,
          25
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Implement Circuit Breaker for External Dependencies",
        "description": "Implement circuit breaker pattern for external dependencies.",
        "details": "1. Implement CircuitBreaker in infrastructure/resilience/circuit_breaker.go:\n   - Define interface for circuit breaker\n   - Implement state machine (closed, open, half-open)\n   - Add failure counting and thresholds\n   - Implement timeout for recovery\n   - Add metrics for circuit breaker state\n2. Apply circuit breaker to file system operations\n3. Apply circuit breaker to database operations\n4. Implement fallback mechanisms for critical operations\n\nUse a lightweight circuit breaker library like github.com/sony/gobreaker (v0.5.0). Implement proper logging for circuit breaker state changes.",
        "testStrategy": "Create unit tests for circuit breaker logic. Test state transitions. Test failure counting and recovery. Verify metrics are properly updated. Test fallback mechanisms.",
        "priority": "low",
        "dependencies": [
          20,
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Implement Application Assembly and Dependency Injection",
        "description": "Create application assembly with proper dependency injection.",
        "details": "1. Implement application assembly in cmd/server/main.go:\n   - Create all components with proper dependencies\n   - Wire up layers (domain, application, infrastructure)\n   - Configure HTTP server and routes\n   - Start background workers\n   - Initialize database connection\n2. Use constructor injection for dependencies\n3. Implement clean separation of concerns\n4. Add proper error handling for initialization failures\n\nUse manual dependency injection without external frameworks. Implement proper resource initialization order.",
        "testStrategy": "Create integration tests for application assembly. Verify all components are properly initialized. Test initialization failures. Verify proper dependency injection.",
        "priority": "high",
        "dependencies": [
          19,
          20,
          21,
          22,
          25,
          29,
          30
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-16T18:05:49.277Z",
      "updated": "2025-09-17T07:03:35.362Z",
      "description": "Tasks for master context"
    }
  }
}